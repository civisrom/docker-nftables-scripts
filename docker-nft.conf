#!/usr/sbin/nft -f
#
# Интегрированный конфиг nftables + vpnbot (Docker)
#
# Требования:
#   1. Docker: /etc/docker/daemon.json: { "iptables": false }
#   2. IP forwarding: sysctl -w net.ipv4.ip_forward=1
#      Persistent: echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.d/docker.conf
#
# vpnbot docker-compose.yml определяет:
#   Сеть default:  10.10.0.0/24 (все контейнеры)
#   Сеть xray:     10.10.1.0/24 (nginx ↔ xray)
#   VPN-клиенты:   10.0.1.0/24 (WG), 10.0.2.0/24 (OC), 10.0.3.0/24 (WG1)

# Очищаем существующие правила
flush ruleset

# ─── vpnbot: адреса контейнеров (из docker-compose.yml) ──────────────
define UPSTREAM_IP  = 10.10.0.10
define NGINX_IP     = 10.10.0.2
define WG_IP        = 10.10.0.4
define WG1_IP       = 10.10.0.14
define ADGUARD_IP   = 10.10.0.5

# ─── vpnbot: порты (из .env) ─────────────────────────────────────────
define WGPORT       = 51820
define WG1PORT      = 51821

table ip filter {

    # ─── Геолокация / ASN ───────────────────────────────────────────────
    include "/opt/maxmind/list/try/geoip-def-try.nft"
    include "/opt/maxmind/list/try/geoip-ipv4.nft"

    include "/opt/maxmind/list/asn_nft/geoip-def-asn.nft"
    include "/opt/maxmind/list/asn_nft/geoip-ipv4.nft"

#    include "/opt/maxmind/list/nftables/drop/geoip-def-ruasndrop.nft"
#    include "/opt/maxmind/list/nftables/drop/geoip-ipv4.nft"

#    include "/opt/maxmind/list/test/1/geoip-def-test.nft"
#    include "/opt/maxmind/list/test/1/geoip-ipv4.nft"

    # ─── Именованные наборы ─────────────────────────────────────────────

    # DNS-серверы (upstream для AdGuard и контейнеров)
    set dns_servers {
        type ipv4_addr
        elements = { 8.8.8.8, 1.1.1.1, 8.8.4.4, 1.0.0.1 }
    }

    # Docker-подсети vpnbot
    set docker_nets {
        type ipv4_addr
        flags interval
        elements = { 10.10.0.0/24, 10.10.1.0/24 }
    }

    # Подсети VPN-клиентов (WG, OC, WG1)
    set vpn_clients {
        type ipv4_addr
        flags interval
        elements = { 10.0.1.0/24, 10.0.2.0/24, 10.0.3.0/24 }
    }

    # ─── Маркировка по GeoIP/ASN (input) ───────────────────────────────
    chain geoip-mark-input {
        type filter hook input priority -1; policy accept;
        meta mark set ip saddr map @try
        meta mark set ip saddr map @asn
    }

    # ─── Маркировка по GeoIP/ASN (forward) ─────────────────────────────
    chain geoip-mark-forward {
        type filter hook forward priority -1; policy accept;
        meta mark set ip saddr map @try
        meta mark set ip saddr map @asn
    }

    # ─── INPUT ──────────────────────────────────────────────────────────
    chain input {
        type filter hook input priority 0; policy drop;

        # Blacklist
        meta mark $BLACKLIST log prefix "IPTABLES-RK: " counter drop

        # ASN — разрешённые порты хоста
        meta mark $ASN tcp dport { 443, 22 } counter accept
        meta mark $ASN udp dport 443 counter accept

        # ICMP
        ip protocol icmp icmp type echo-reply limit rate 15/second counter accept
        ip protocol icmp drop

        # Запрет протоколов 41 (6in4), 47 (GRE), 4 (IPIP)
        ip protocol 41 drop
        ip protocol 47 drop
        ip protocol 4 drop

        # Базовые правила
        ct state { related, established } counter accept
        iifname "lo" counter accept

        # ── vpnbot: трафик от Docker-контейнеров к хосту ──
        ip saddr @docker_nets counter accept

        # ── vpnbot: WireGuard UDP от разрешённых ASN ──
        meta mark $ASN udp dport $WGPORT counter accept
        meta mark $ASN udp dport $WG1PORT counter accept

        # Логируем и дропаем остальное
        log prefix "INPUT-DROP: " level warn limit rate 10/second counter drop
        tcp dport 1-65535 drop
        udp dport 1-65535 drop
    }

    # ─── FORWARD (Docker + ASN фильтрация) ─────────────────────────────
    chain forward {
        type filter hook forward priority 0; policy drop;

        # Разрешить established/related (возвратный трафик)
        ct state { established, related } counter accept

        # ── Внутренний трафик Docker ──
        # Контейнеры ↔ контейнеры (10.10.0.0/24, 10.10.1.0/24)
        ip saddr @docker_nets ip daddr @docker_nets counter accept

        # Трафик VPN-клиентов ↔ Docker-контейнеры
        # (WG/OC клиенты обращаются к AdGuard, другим сервисам)
        ip saddr @vpn_clients ip daddr @docker_nets counter accept
        ip saddr @docker_nets ip daddr @vpn_clients counter accept

        # ── Контейнеры → DNS (для AdGuard upstream, DoH) ──
        ip saddr @docker_nets ip daddr @dns_servers udp dport 53 counter accept
        ip saddr @docker_nets ip daddr @dns_servers tcp dport { 53, 443 } counter accept
        ip saddr @docker_nets ip daddr @dns_servers udp dport 443 counter accept

        # ── VPN-маршрутизация: контейнеры → интернет ──
        # vpnbot контейнеры (WG, Xray, OC, SS, NaiveProxy, Hysteria)
        # маршрутизируют клиентский VPN-трафик через себя в интернет.
        # Без этого правила VPN-клиенты не смогут выходить в сеть.
        ip saddr @docker_nets counter accept

        # ── Снаружи → контейнеры (ASN фильтрация) ──
        # Blacklist — блокируем
        meta mark $BLACKLIST ip daddr @docker_nets log prefix "DOCKER-BL: " counter drop
        # ASN — разрешаем доступ к контейнерам (после DNAT)
        meta mark $ASN ip daddr @docker_nets counter accept

        # Логируем дроп
        log prefix "FORWARD-DROP: " level warn limit rate 10/second counter drop
    }

    # ─── OUTPUT ─────────────────────────────────────────────────────────
    # Исходящий трафик хоста: разрешаем всё.
    # Хосту нужен доступ для: curl (ipinfo.io при старте vpnbot),
    # Docker DNS forwarding, apt, обновлений и т.д.
    chain output {
        type filter hook output priority 0; policy accept;
    }
}

# ─── Docker NAT (vpnbot) ───────────────────────────────────────────────
table ip dockernat {

    # ── DNAT: проброс портов к контейнерам ──
    # fib daddr type local = только трафик адресованный хосту (входящий извне).
    # Без этого условия ВСЕ пакеты на порт 443 (включая исходящие от
    # контейнеров к api.telegram.org, 1.1.1.1 и т.д.) перенаправлялись
    # бы к upstream-контейнеру, ломая весь исходящий HTTPS.
    chain prerouting {
        type nat hook prerouting priority -100;

        # HTTP → nginx
        fib daddr type local tcp dport 80 dnat to $NGINX_IP:80

        # HTTPS/QUIC → upstream (SNI-маршрутизация к xray, oc, naive, nginx)
        fib daddr type local tcp dport 443 dnat to $UPSTREAM_IP:443
        fib daddr type local udp dport 443 dnat to $UPSTREAM_IP:443

        # WireGuard
        fib daddr type local udp dport $WGPORT dnat to $WG_IP:$WGPORT
        fib daddr type local udp dport $WG1PORT dnat to $WG1_IP:$WG1PORT
    }

    chain output {
        type nat hook output priority -100;
        # Локальные подключения к опубликованным портам (от хоста)
        ip daddr != 127.0.0.0/8 fib daddr type local tcp dport 80 dnat to $NGINX_IP:80
        ip daddr != 127.0.0.0/8 fib daddr type local tcp dport 443 dnat to $UPSTREAM_IP:443
        ip daddr != 127.0.0.0/8 fib daddr type local udp dport 443 dnat to $UPSTREAM_IP:443
    }

    # ── Masquerade: контейнеры → интернет ──
    chain postrouting {
        type nat hook postrouting priority 100;

        # Не маскировать внутренний трафик Docker (между подсетями)
        ip saddr 10.10.0.0/24 ip daddr { 10.10.0.0/24, 10.10.1.0/24 } return
        ip saddr 10.10.1.0/24 ip daddr { 10.10.0.0/24, 10.10.1.0/24 } return

        # Не маскировать трафик к VPN-клиентам
        ip daddr { 10.0.1.0/24, 10.0.2.0/24, 10.0.3.0/24 } return

        # Трафик из Docker-подсетей → интернет (masquerade на внешний IP)
        ip saddr 10.10.0.0/24 masquerade
        ip saddr 10.10.1.0/24 masquerade
    }
}
